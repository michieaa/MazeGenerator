<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Maze</title>
  <link rel="stylesheet" href="MazeGenMain.css">
</head>
<body>
<div id="mazecanvas">
  <canvas id="sig-canvas">Your browser doesn't support canvas.</canvas>
</div>
<button onclick="NewMaze(z)">NewMaze</button>
<button onclick="NewerMaze()">NewerMaze</button>
<script>
  var canvas = document.getElementById("sig-canvas"); //Specifies canvas to draw on
  var ctx = canvas.getContext("2d") //Sets ctx as a 2d 'plane' of the canvas
  var scale = 1; //This is implemented for future accessibility if the canvas is resized
  canvas.width = 500 * scale;
  canvas.height = 500 * scale;

  var z = 1; //This is the value for the currently selected maze

  function NewMaze(current){
    z = RandSelect(current);
    console.log(z)
    ctx.clearRect(0, 0, canvas.width, canvas.height); //This may not clear certain canvas objects
    drawhorslop(z); //Horizontal must be called first as it begins a new path.
    drawvertslop(z);
  }

  function RandSelect(){ //Random number within the range of z-indexes
    do {
      var randInt = Math.floor(Math.random() * 4);
      console.log(randInt);
    } while (randInt === z);
    console.log(randInt)
    return(randInt);
  }
  //Horizontal lines organised to be visually accurate when displayed in a table (z,y,x)
  // Includes outside boundary lines
  let horizontals = [
    [1,1,1,1,1],
    [1,1,1,1,1],
    [1,1,1,1,1],
    [1,1,1,1,1],
    [1,1,1,1,1],
    [1,1,1,1,1]
  ];
  //Vertical lines organised to be visually accurate when displayed in a table (z,y,x)
  // Includes outside boundary lines
  let verticals = [
    [1,1,1,1,1,1],
    [1,1,1,1,1,1],
    [1,1,1,1,1,1],
    [1,1,1,1,1,1],
    [1,1,1,1,1,1]
  ];
  console.table(horizontals);
  console.table(verticals);
testiterator = 0

  mazecells = [
    [1,0,0,0,0],
    [0,0,0,0,0],
    [0,0,0,0,0],
    [0,0,0,0,0],
    [0,0,0,0,0]];

  mazefront = [[0,0]]

  adjcells = []

  function NewerMaze() {
    ResetMaze();
    while(mazefront.length>0){
      testiterator = testiterator + 1
      console.log(testiterator)
      let index = RandIndex();
      //CheckAdj(index)
      adjcells.splice(0,adjcells.length)
      mazeFrontIndex = index
      if(mazefront[mazeFrontIndex][1]+1 < mazecells[0].length) {
        if (mazecells[mazefront[mazeFrontIndex][0]][mazefront[mazeFrontIndex][1] + 1] === 0) {
          adjcells.push(1)
        }
      }
      if(mazefront[mazeFrontIndex][1]-1 != -1) {
        if (mazecells[mazefront[mazeFrontIndex][0]][mazefront[mazeFrontIndex][1] - 1] === 0) {
          adjcells.push(2)
        }
      }
      if(mazefront[mazeFrontIndex][0]+1 < mazecells.length ) {
        if (mazecells[mazefront[mazeFrontIndex][0] + 1][mazefront[mazeFrontIndex][1]] === 0) {
          adjcells.push(3)
        }
      }
      if (mazefront[mazeFrontIndex][0]-1 != -1) {
        if ((mazecells[mazefront[mazeFrontIndex][0] - 1][mazefront[mazeFrontIndex][1]] === 0)) {
          adjcells.push(4)
        }
      }
      console.log(adjcells)
      if(adjcells.length === 0){
        mazefront.splice(index,1)
      } else{
        let randAdj = Math.floor(Math.random() * adjcells.length)
        if(adjcells[randAdj] == 1){
          mazefront.push([mazefront[index][0], mazefront[index][1]+1])
          mazecells[mazefront[index][0]][mazefront[index][1]+1] = 1
          verticals[mazefront[index][0]][mazefront[index][1]+1] = 0
        } else if(adjcells[randAdj] == 2){
          mazefront.push([mazefront[index][0], mazefront[index][1]-1])
          mazecells[mazefront[index][0]][mazefront[index][1]-1] = 1
          verticals[mazefront[index][0]][mazefront[index][1]] = 0
        } else if(adjcells[randAdj] == 3){
          mazefront.push([mazefront[index][0]+1, mazefront[index][1]])
          mazecells[mazefront[index][0]+1][mazefront[index][1]] = 1
          horizontals[mazefront[index][0]+1][mazefront[index][1]] = 0
        } else if(adjcells[randAdj] == 4){
          mazefront.push([mazefront[index][0]-1, mazefront[index][1]])
          mazecells[mazefront[index][0]-1][mazefront[index][1]] = 1
          horizontals[mazefront[index][0]][mazefront[index][1]] = 0
        }

      }
    }
    drawhorslop(0)
    drawvertslop(0)
  }

  function ResetMaze(){ //Clears canvas for new maze to be drawn and resets matrices to initial values.
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(i in mazecells){
      for(j in mazecells[i]){
        mazecells[i][j] = 0
      }
    }
    for(i in verticals){
      for(j in verticals[i]){
        verticals[i][j] = 1
      }
    }
    for(i in horizontals){
      for(j in horizontals[i]){
        horizontals[i][j] = 1
      }
    }
    mazefront = [[0,0]]
  }

  function RandIndex(){
    return Math.floor(Math.random() * mazefront.length)
  }

  // function CheckAdj(mazeFrontIndex){
  //   adjcells.splice(0,adjcells.length)
  //   if(mazecells[mazefront[mazeFrontIndex][0]][mazefront[mazeFrontIndex][1]+1] === 0){
  //     adjcells.push(1)
  //   }
  //   if(mazecells[mazefront[mazeFrontIndex][0]][mazefront[mazeFrontIndex][1]-1] === 0){
  //     adjcells.push(2)
  //   }
  //   if(mazecells[mazefront[mazeFrontIndex][0]+1][mazefront[mazeFrontIndex][1]] === 0){
  //     adjcells.push(3)
  //   }
  //   if(mazecells[mazefront[mazeFrontIndex][0]-1][mazefront[mazeFrontIndex][1]] === 0){
  //     adjcells.push(4)
  //   }
  // }

  function NewDraw(frontindex,direction){

  }

  //Loops through the horizontal matrix to draw the horizontal lines
  function drawhorslop() {
    ctx.beginPath(); //Begins new path: Allows for canvas to be more easily cleared.
    for(y in horizontals){
      var x = 0
      while (x <= horizontals[y].length){
        if (horizontals[y][x] == 1){
          ctx.moveTo(x*100,y*100);
          ctx.lineTo(x*100+100,y*100);
          ctx.stroke();
        } else {
        }
        x = x + 1
      }
    }
  }

  //Loops through the vertical matrix to draw the vertical components.
  function drawvertslop() {
    for(y in verticals){
      var x = 0
      while (x <= verticals[y].length){
        if (verticals[y][x] == 1){
          ctx.moveTo(x*100,y*100);
          ctx.lineTo(x*100,y*100+100);
          ctx.stroke();
        } else {
        }
        x = x + 1
      }
    }
  }

</script>
</body>
</html>